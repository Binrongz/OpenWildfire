#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Report Generator (Enhanced for Camera Integration)
Generate technical report of fire risk assessment in English, support JSON format
"""

import json
import os
from datetime import datetime
from typing import List, Dict, Optional
import logging

logger = logging.getLogger(__name__)

class ReportGenerator:
    """Report Generator Class (Enhanced)"""
    
    def __init__(self, output_dir: str = "reports"):
        """
        Initialize the report generator
        
        Args:
            output_dir: Report output directory
        """
        self.output_dir = output_dir
        
        # Create the output directory if it does not exist
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            logger.info(f"Create the output directory: {output_dir}")
    
    def generate_technical_report(self, assessment_result: Dict, model_name: str = "openai/gpt-oss-20b") -> Dict:
        """
        Generate a technical style fire risk assessment report
        
        Args:
            assessment_result: AI evaluation results (both raw data and AI analytics)
            model_name: Name of the AI model to use
            
        Returns:
            Formatted technical report dictionary
        """
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
        
        # Extraction data
        sensor_data = assessment_result.get('sensor_data', {})
        ai_assessment = assessment_result.get('ai_assessment', {})
        location = sensor_data.get('location', {})
        coordinates = location.get('coordinates', {})
        camera_assessment = sensor_data.get('camera_assessment', {})
        weather = sensor_data.get('weather', {})
        fire_risk_data = sensor_data.get('fire_risk_data', {})
        fire_stations = sensor_data.get('fire_stations', {})
        
        # Build tech reports
        report = {
            "report_header": {
                "title": "FIRE RISK ASSESSMENT REPORT",
                "generation_time": timestamp,
                "ai_model": model_name,
                "report_id": f"FRA_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            },
            
            "disclaimer": {
                "warning": "IMPORTANT: This fire risk assessment is generated by an AI system for informational purposes only.",
                "limitations": [
                    "This assessment is based on available sensor data and weather information at the time of analysis",
                    "AI-generated recommendations should be verified by qualified fire safety professionals",
                    "Real-time conditions may differ from the data used in this assessment",
                    "This system is not a substitute for professional fire safety judgment"
                ],
                "liability": "Users are responsible for verifying information and making final decisions regarding fire safety actions",
                "emergency_notice": "In case of immediate fire danger, contact emergency services (911) immediately regardless of this assessment"
            },
            
            "executive_summary": {
                "risk_level": ai_assessment.get('risk_level', 'Unknown'),
                "risk_score": f"{ai_assessment.get('risk_score', 0)}/5",
                
                # Ensure risk_level and risk_score same
                "location": location.get('county', 'Unknown'),
                "assessment_time": timestamp,
                # "confidence": ai_assessment.get('confidence', 'Unknown')
            },
            
            "location_information": {
                "coordinates": {
                    "latitude": f"{coordinates.get('lat', 0):.6f}°N",
                    "longitude": f"{abs(coordinates.get('lon', 0)):.6f}°W"
                },
                "administrative": {
                    "city": location.get('city', 'Unknown'),
                    "county": location.get('county', 'Unknown'),
                    "state": "California"
                },
                "geographic": {
                    "land_type": location.get('land_type', 'Unknown'),
                    "grid_point": location.get('nearest_grid_point', 'Unknown'),
                    "display_name": location.get('display_name', 'Unknown')
                }
            },
            
            "camera_detection_analysis": self._format_camera_analysis(camera_assessment),
            
            "weather_conditions": self._format_weather_data(weather),
            
            "fire_risk_assessment": {
                "fhsz_classification": {
                    "risk_level": fire_risk_data.get('fhsz_risk', 'Unknown'),
                    "description": fire_risk_data.get('fhsz_risk_level', 'Unknown')
                },
                "historical_fire_data": self._format_fire_history(fire_risk_data),
                "ai_risk_analysis": {
                    "assessment": ai_assessment.get('reasoning', 'No analysis available'),
                    # "confidence_level": ai_assessment.get('confidence', 'Unknown'),
                    "risk_factors": self._extract_risk_factors(ai_assessment.get('reasoning', ''))
                }
            },
            
            "emergency_recommendations": {
                "immediate_actions": assessment_result.get('emergency_recommendations', []),
                "monitoring_requirements": assessment_result.get('monitoring_recommendations', []),  # 使用 ai
                "resource_deployment": self._generate_resource_recommendations(ai_assessment.get('risk_score', 0), fire_stations)
            },
            
            "fire_station_resources": self._format_fire_stations(fire_stations),
            
            "technical_metadata": {
                "data_sources": {
                    "camera_data": f"{camera_assessment.get('total_cameras', 0)} cameras",
                    "weather_source": weather.get('source', 'Unknown'),
                    "geographic_database": "California Fire Risk Enhanced Dataset"
                },
                "processing_details": {
                    # "detection_confidence": camera_assessment.get('detection_confidence', 'Unknown'),
                    "grid_point_match": "Nearest neighbor algorithm"
                }
            }
        }
        
        return report
    
    def _format_camera_analysis(self, camera_data: Dict) -> Dict:
        """Format camera analysis data"""
        return {
            "deployment_summary": {
                "total_cameras": camera_data.get('total_cameras', 0),
                "cluster_radius": "500 meters",
                "camera_ids": camera_data.get('camera_ids', [])
            },
            "detection_status": {
                "fire_detections": f"{camera_data.get('cameras_detecting_fire', 0)}/{camera_data.get('total_cameras', 0)} cameras",
                "smoke_detections": f"{camera_data.get('cameras_detecting_smoke', 0)}/{camera_data.get('total_cameras', 0)} cameras",
                "normal_status": f"{camera_data.get('cameras_normal', 0)}/{camera_data.get('total_cameras', 0)} cameras"
            },
            "detection_rates": {
                "fire_detection_rate": f"{camera_data.get('fire_detection_rate', 0):.1%}",
                "smoke_detection_rate": f"{camera_data.get('smoke_detection_rate', 0):.1%}"
            },
            "assessment": {
                "primary_status": camera_data.get('primary_detection_status', 'normal'),
                # "confidence_level": camera_data.get('detection_confidence', 'Unknown'),
                "detection_summary": camera_data.get('detection_summary', 'No detection data available')
            }
        }
    
    def _format_weather_data(self, weather: Dict) -> Dict:
        """Format weather data"""
        temp = weather.get('temperature', {})
        wind = weather.get('wind_speed', {})
        
        return {
            "temperature": {
                "fahrenheit": f"{temp.get('fahrenheit', 'N/A')}°F",
                "celsius": f"{temp.get('celsius', 'N/A')}°C"
            },
            "humidity": f"{weather.get('humidity', 'N/A')}%",
            "wind_speed": {
                "mph": f"{wind.get('mph', 'N/A')} mph",
                "mps": f"{wind.get('mps', 'N/A')} m/s"
            },
            "conditions": weather.get('weather_description', 'Unknown'),
            "data_source": weather.get('source', 'Unknown')
        }
    
    def _format_fire_history(self, fire_history: Dict) -> Dict:
        """Format fire historic data"""
        return {
            "total_incidents": fire_history.get('fire_count', 0),
            "incident_dates": fire_history.get('fire_dates', []),
            "recent_activity": "Yes" if fire_history.get('fire_count', 0) > 0 else "No historical fires recorded",
            "fire_frequency": self._calculate_fire_frequency(fire_history.get('fire_dates', []))
        }
    
    def _calculate_fire_frequency(self, fire_dates: List[str]) -> str:
        """Calculating fire frequency"""
        if not fire_dates:
            return "No historical data"
        
        try:
            years_with_fires = len(set(date.split('/')[-1] for date in fire_dates if '/' in date))
            if years_with_fires <= 1:
                return "Isolated incidents"
            elif years_with_fires <= 3:
                return "Infrequent"
            else:
                return "Recurring pattern"
        except:
            return "Unable to determine"
    
    def _extract_risk_factors(self, reasoning: str) -> List[str]:
        """Extracting risk factors from AI inference"""
        risk_keywords = {
            'temperature': ['temperature', 'heat', 'hot'],
            'humidity': ['humidity', 'dry', 'moisture'],
            'wind': ['wind', 'gusts', 'breeze'],
            'detection': ['fire', 'smoke', 'detection', 'camera'],
            'weather': ['weather', 'conditions', 'climate']
        }
        
        factors = []
        reasoning_lower = reasoning.lower()
        
        for category, keywords in risk_keywords.items():
            if any(keyword in reasoning_lower for keyword in keywords):
                factors.append(category.title())
        
        return factors if factors else ["General risk assessment"]
    
    def _generate_monitoring_recommendations(self, risk_score: int) -> List[str]:
        return []
        
    def _generate_resource_recommendations(self, risk_score: int, fire_stations: Dict) -> List[str]:
        """Generate resource deployment recommendations"""
        recommendations = []
        
        # Add specific fire station information
        stations_detail = fire_stations.get('stations_detail', [])
        if stations_detail:
            nearest = stations_detail[0]
            name = nearest.get('name', 'Unknown')
            distance_km = nearest.get('distance_km', 'N/A')
            distance_mi = nearest.get('distance_mi', 'N/A')
    
            recommendations.append(f"Primary response: {name} ({distance_km}km / {distance_mi}mi)")
        
        return recommendations
    
    def _format_fire_stations(self, fire_stations: Dict) -> Dict:
        """Format fire stations information"""
        stations_detail = fire_stations.get('stations_detail', [])
        
        formatted_stations = []
        for station in stations_detail:
            formatted_station = {
                "name": station.get('name', 'Unknown'),
                "distance": {
                    "kilometers": f"{station.get('distance_km', 'N/A')} km",
                    "miles": f"{station.get('distance_mi', 'N/A')} miles"
                },
                "location": station.get('location', 'Unknown')
            }
            formatted_stations.append(formatted_station)
        
        return {
            "total_stations": fire_stations.get('station_count', 0),
            "coverage_summary": self._generate_coverage_summary(stations_detail),
            "station_details": formatted_stations
        }
    
    def _categorize_response_distance(self, distance_km: float) -> str:
        """Classification response distance"""
        try:
            distance = float(distance_km)
            if distance <= 5:
                return "Immediate response (<5km)"
            elif distance <= 15:
                return "Rapid response (5-15km)"
            elif distance <= 30:
                return "Standard response (15-30km)"
            else:
                return "Extended response (>30km)"
        except:
            return "Unknown response time"
    
    def _generate_coverage_summary(self, stations: List[Dict]) -> str:
        """Generate a coverage summary"""
        if not stations:
            return "No fire stations in range"
        
        distances = []
        for station in stations:
            try:
                distances.append(float(station.get('distance_km', float('inf'))))
            except:
                continue
        
        if not distances:
            return "Unable to determine coverage"
        
        min_distance = min(distances)
        if min_distance <= 5:
            return "Excellent coverage - immediate response available"
        elif min_distance <= 15:
            return "Good coverage - rapid response available"
        elif min_distance <= 30:
            return "Adequate coverage - standard response time"
        else:
            return "Limited coverage - extended response time"
    
    def save_json_report(self, report_dict: Dict, filename: str = None) -> str:
        """
        Save JSON reports
        
        Args:
            report_dict: report dictionaries
            filename: filename（optional）
            
        Returns:
            Path to the saved file
        """
        if filename is None:
            location = report_dict.get('executive_summary', {}).get('location', 'Unknown')
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f'fire_risk_assessment_{location.replace(" ", "")}_{timestamp}.json'
        
        file_path = os.path.join(self.output_dir, filename)
        
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(report_dict, f, ensure_ascii=False, indent=2)
            
            logger.info(f"The JSON report has been saved to: {file_path}")
            return file_path
            
        except Exception as e:
            logger.error(f"Saving JSON reports failure: {str(e)}")
            return ""
    
    def generate_complete_report(self, assessment_result: Dict, model_name: str = "openai/gpt-oss-20b") -> str:
        """
        Generate a complete fire risk assessment report (JSON format only)
        
        Args:
            assessment_result: AI Evaluation Results
            model_name: AI Model Name
            
        Returns:
            JSON path
        """
        logger.info("Start generating fire risk assessment report...")
        
        # Generating technical reports
        report_dict = self.generate_technical_report(assessment_result, model_name)
        
        # Saving JSON
        json_file = self.save_json_report(report_dict)
        
        logger.info(f"Report generation is complete: JSON={json_file}")
        
        return json_file